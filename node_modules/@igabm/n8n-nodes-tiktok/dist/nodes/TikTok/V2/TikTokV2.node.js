"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TikTokV2 = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const VideoPostDescription_1 = require("./VideoPostDescription");
const PhotoPostDescription_1 = require("./PhotoPostDescription");
const PostStatusDescription_1 = require("./PostStatusDescription");
const UserProfileDescription_1 = require("./UserProfileDescription");
const SearchDescription_1 = require("./SearchDescription");
const GenericFunctions_1 = require("./GenericFunctions");
class TikTokV2 {
    constructor(baseDescription) {
        this.methods = {
            loadOptions: {
                async getLanguages() {
                    const returnData = [];
                    const languages = ['English', 'Spanish', 'French'];
                    for (const language of languages) {
                        returnData.push({
                            name: language,
                            value: language.toLowerCase(),
                        });
                    }
                    return returnData;
                },
            },
        };
        this.description = {
            ...baseDescription,
            version: 2,
            description: 'Upload and manage TikTok videos and photos, and retrieve profile information',
            subtitle: '={{$parameter["operation"] + ":" + $parameter["resource"]}}',
            defaults: {
                name: 'TikTok',
            },
            inputs: ["main"],
            outputs: ["main"],
            credentials: [
                {
                    name: 'tiktokOAuth2Api',
                    required: true,
                },
            ],
            properties: [
                {
                    displayName: 'Resource',
                    name: 'resource',
                    type: 'options',
                    noDataExpression: true,
                    options: [
                        {
                            name: 'Photo Post',
                            value: 'photoPost',
                            description: 'Upload a photo to TikTok',
                        },
                        {
                            name: 'Post Status',
                            value: 'postStatus',
                            description: 'Check the status of a post',
                        },
                        {
                            name: 'Search',
                            value: 'search',
                            description: 'Search for hashtags or sounds',
                        },
                        {
                            name: 'User Profile',
                            value: 'userProfile',
                            description: 'Retrieve profile data of a TikTok user',
                        },
                        {
                            name: 'Video Post',
                            value: 'videoPost',
                            description: 'Upload a video to TikTok',
                        },
                    ],
                    default: 'videoPost',
                },
                ...VideoPostDescription_1.videoPostOperations,
                ...VideoPostDescription_1.videoPostFields,
                ...PhotoPostDescription_1.photoPostOperations,
                ...PhotoPostDescription_1.photoPostFields,
                ...PostStatusDescription_1.postStatusOperations,
                ...PostStatusDescription_1.postStatusFields,
                ...UserProfileDescription_1.userProfileOperations,
                ...UserProfileDescription_1.userProfileFields,
                ...SearchDescription_1.searchOperations,
                ...SearchDescription_1.searchFields,
            ],
        };
    }
    async execute() {
        var _a, _b, _c, _d, _e;
        const items = this.getInputData();
        const returnData = [];
        const length = items.length;
        let responseData;
        const resource = this.getNodeParameter('resource', 0);
        const operation = this.getNodeParameter('operation', 0);
        for (let i = 0; i < length; i++) {
            try {
                if (resource === 'videoPost') {
                    if (operation === 'upload') {
                        const source = this.getNodeParameter('source', i);
                        const privacyLevel = this.getNodeParameter('privacyLevel', i);
                        const additionalFields = this.getNodeParameter('additionalFields', i, {});
                        const postInfo = {
                            privacy_level: privacyLevel,
                        };
                        if (additionalFields.title) {
                            postInfo.title = additionalFields.title;
                        }
                        if (additionalFields.disableDuet !== undefined) {
                            postInfo.disable_duet = additionalFields.disableDuet;
                        }
                        if (additionalFields.disableStitch !== undefined) {
                            postInfo.disable_stitch = additionalFields.disableStitch;
                        }
                        if (additionalFields.disableComment !== undefined) {
                            postInfo.disable_comment = additionalFields.disableComment;
                        }
                        if (additionalFields.videoCoverTimestampMs !== undefined) {
                            postInfo.video_cover_timestamp_ms = additionalFields.videoCoverTimestampMs;
                        }
                        if (additionalFields.brandContentToggle !== undefined) {
                            postInfo.brand_content_toggle = additionalFields.brandContentToggle;
                        }
                        if (additionalFields.brandOrganicToggle !== undefined) {
                            postInfo.brand_organic_toggle = additionalFields.brandOrganicToggle;
                        }
                        if (additionalFields.isAigc !== undefined) {
                            postInfo.is_aigc = additionalFields.isAigc;
                        }
                        const sourceInfo = {
                            source,
                        };
                        if (source === 'PULL_FROM_URL') {
                            const videoUrl = this.getNodeParameter('videoUrl', i);
                            sourceInfo.video_url = videoUrl;
                            const body = {
                                post_info: postInfo,
                                source_info: sourceInfo,
                            };
                            responseData = await GenericFunctions_1.tiktokApiRequest.call(this, 'POST', '/post/publish/video/init/', body);
                        }
                        if (source === 'FILE_UPLOAD') {
                            const binaryProperty = this.getNodeParameter('binaryProperty', i);
                            const item = (_a = items[i].binary) === null || _a === void 0 ? void 0 : _a[binaryProperty];
                            if (!item) {
                                throw new n8n_workflow_1.NodeOperationError(this.getNode(), `No binary data property "${binaryProperty}" set`, { itemIndex: i });
                            }
                            const dataBuffer = Buffer.from(item.data, 'base64');
                            sourceInfo.video_size = dataBuffer.length;
                            sourceInfo.chunk_size = dataBuffer.length;
                            sourceInfo.total_chunk_count = 1;
                            const body = {
                                post_info: postInfo,
                                source_info: sourceInfo,
                            };
                            responseData = await GenericFunctions_1.tiktokApiRequest.call(this, 'POST', '/post/publish/video/init/', body);
                            const uploadUrl = responseData.upload_url;
                            if (!uploadUrl) {
                                throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Upload URL not returned');
                            }
                            await this.helpers.httpRequest({
                                method: 'PUT',
                                url: uploadUrl,
                                body: dataBuffer,
                                headers: {
                                    'Content-Type': item.mimeType || 'video/mp4',
                                    'Content-Length': dataBuffer.length,
                                    'Content-Range': `bytes 0-${dataBuffer.length - 1}/${dataBuffer.length}`,
                                },
                                json: false,
                            });
                        }
                    }
                }
                if (resource === 'photoPost') {
                    if (operation === 'upload') {
                        let photoUrls = this.getNodeParameter('photoUrls', i);
                        if (typeof photoUrls === 'string') {
                            photoUrls = photoUrls
                                .split(',')
                                .map((url) => url.trim())
                                .filter((url) => url);
                        }
                        const photoCoverIndex = this.getNodeParameter('photoCoverIndex', i);
                        const postMode = this.getNodeParameter('postMode', i);
                        const additionalFields = this.getNodeParameter('additionalFields', i);
                        const postInfo = {};
                        if (additionalFields.title) {
                            postInfo.title = additionalFields.title;
                        }
                        if (additionalFields.description) {
                            postInfo.description = additionalFields.description;
                        }
                        if (additionalFields.privacyLevel) {
                            postInfo.privacy_level = additionalFields.privacyLevel;
                        }
                        if (additionalFields.disableComment !== undefined) {
                            postInfo.disable_comment = additionalFields.disableComment;
                        }
                        if (additionalFields.autoAddMusic !== undefined) {
                            postInfo.auto_add_music = additionalFields.autoAddMusic;
                        }
                        if (additionalFields.brandContentToggle !== undefined) {
                            postInfo.brand_content_toggle = additionalFields.brandContentToggle;
                        }
                        if (additionalFields.brandOrganicToggle !== undefined) {
                            postInfo.brand_organic_toggle = additionalFields.brandOrganicToggle;
                        }
                        if (postMode === 'DIRECT_POST' && postInfo.privacy_level === undefined) {
                            throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Privacy Level must be set for Direct Post', { itemIndex: i });
                        }
                        const body = {
                            post_info: postInfo,
                            source_info: {
                                source: 'PULL_FROM_URL',
                                photo_cover_index: photoCoverIndex,
                                photo_images: photoUrls,
                            },
                            post_mode: postMode,
                            media_type: 'PHOTO',
                        };
                        responseData = await GenericFunctions_1.tiktokApiRequest.call(this, 'POST', '/post/publish/content/init/', body);
                    }
                }
                if (resource === 'postStatus') {
                    if (operation === 'get') {
                        const publishId = this.getNodeParameter('publishId', i);
                        const body = { publish_id: publishId };
                        responseData = await GenericFunctions_1.tiktokApiRequest.call(this, 'POST', '/post/publish/status/fetch/', body);
                    }
                }
                if (resource === 'search') {
                    const query = this.getNodeParameter('query', i);
                    const cursor = this.getNodeParameter('cursor', i, 0);
                    const limit = this.getNodeParameter('limit', i, 20);
                    const qs = { query, cursor, max_count: limit };
                    if (operation === 'hashtag') {
                        responseData = await GenericFunctions_1.tiktokApiRequest.call(this, 'GET', '/hashtag/search/', {}, qs);
                        responseData = (_c = (_b = responseData.hashtags) !== null && _b !== void 0 ? _b : responseData.results) !== null && _c !== void 0 ? _c : responseData;
                    }
                    if (operation === 'sound') {
                        responseData = await GenericFunctions_1.tiktokApiRequest.call(this, 'GET', '/sound/search/', {}, qs);
                        responseData = (_e = (_d = responseData.sounds) !== null && _d !== void 0 ? _d : responseData.results) !== null && _e !== void 0 ? _e : responseData;
                    }
                }
                if (resource === 'userProfile') {
                    if (operation === 'get') {
                        const fields = this.getNodeParameter('fields', i);
                        if (!(fields === null || fields === void 0 ? void 0 : fields.length)) {
                            throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'User Profile: "Fields" must include at least one selection.', { itemIndex: i });
                        }
                        const qs = { fields: fields.join(',') };
                        responseData = await GenericFunctions_1.tiktokApiRequest.call(this, 'GET', '/user/info/', {}, qs);
                    }
                    if (operation === 'analytics') {
                        const selectedMetrics = this.getNodeParameter('metrics', i);
                        if (!(selectedMetrics === null || selectedMetrics === void 0 ? void 0 : selectedMetrics.length)) {
                            throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'User Profile: "Metrics" must include at least one selection.');
                        }
                        const metricFieldMap = {
                            followers: 'follower_count',
                            likes: 'likes_count',
                            views: 'video_count',
                        };
                        const fieldList = selectedMetrics
                            .map((metric) => metricFieldMap[metric])
                            .filter(Boolean);
                        const qs = { fields: fieldList.join(',') };
                        responseData = await GenericFunctions_1.tiktokApiRequest.call(this, 'GET', '/user/info/', {}, qs);
                        const user = responseData.user;
                        const metricsData = {};
                        if (user) {
                            for (const metric of selectedMetrics) {
                                const fieldName = metricFieldMap[metric];
                                if (user[fieldName] !== undefined) {
                                    metricsData[metric] = user[fieldName];
                                }
                            }
                        }
                        responseData = metricsData;
                    }
                }
                const executionData = this.helpers.constructExecutionMetaData(this.helpers.returnJsonArray(responseData), { itemData: { item: i } });
                returnData.push(...executionData);
            }
            catch (error) {
                if (this.continueOnFail()) {
                    const executionErrorData = {
                        json: {
                            error: error.message,
                        },
                    };
                    returnData.push(executionErrorData);
                    continue;
                }
                throw error;
            }
        }
        return [returnData];
    }
}
exports.TikTokV2 = TikTokV2;
//# sourceMappingURL=TikTokV2.node.js.map